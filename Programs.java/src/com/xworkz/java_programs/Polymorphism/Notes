Polymorphism :

It is the ability of an object to take many form.
"
"
There are two types of polymorphismare there :

1) Compile time (Static / early binding)
2) Runtime polymorphism (Dynamic / late binding)

* Main advantage of this is it provides the read ability.

1) Compile time :-
Ex: Method overloading :- if the class is having the multiple method with same name  with different type of parameter.
 There are 2 ways : 1) By passsing different number of parameter. 
                                           2) By passing different type of parameter.

* We will not overload the method by return type because there will be ambiguity occur.


   class Compiletime {
          public static void main (String [] args){
               int result = sum (5,10);
               System.out.println(result);
}

   static int sum ( int a,int b) {
              return a+b;
}

   static int ( int a , int b , int c) {
              return a+b+c;
        }
POLYMORPHISM
Poly means many.
Morph means forms.
Polymorphism is a ability of an object to take on many forms.
1. Compile time polymorphism/Static /early binding
2. Run time polymorphism /dynamic /late binding
1. Compile time polymorphism/Static /early binding
Ø Method overloading
Method overloading is a class have multiple methods with same name with different parameters and different types of parameters.
Object behave different in different environment.
Advantage :
Readability increases.
Two methods to method overloading:
1. By passing different number of parameter.
2. By passing different type of parameter.

Ø Class method{
Public static void main(String args[]){
Static int = sum(5,10);
System.out.println(result);
}
Static int sum(int a,int b){
Return a+b;
}
Static int sum (int a,int b,int c){
Return a+b+c;
}
}
}
Static int sum(short a,short b){
System.out.println(“executing method which has short parameter”);
Return a+b;
}
}
Ø Apporva has to tell story to strange and beloved.
public class Apporva{
Public static void main(String[] args){
Stranger s=new Stranger();
Beloved b=new Beloved();
Apporva apporva=new Apporva();
Apporva.speak(strange);
Apporva.speak(beloved);
}
Void speak(stranger s){
System.out.println(“hi,my day was great………”);
}
Void speak(beloved b){
System.out.println(“hi,my day was great and….”+ “you know what happens…….”);
}
}
Ø We can overload a main method by changing the type of parameters.
EX: class Test{
Public static void main(string args[]){
}
Public static void main(int args[]){
}
}
In the above example, jvm always try to find this type of signature - Public static void main(string args[]){
}
Jvm always accepts string array arguments.
Class compileTimePolymorphismTest{
public static void main(string args[]){
short i=10;
short j=5;
multiply(10,5);
}
Static void multiply(int i,int j){
System.out.println(“calling method which takes int”);
System.out.println(“i*j=” + (i*j));
}
Static void multiply(long i,long j){
System.out.println(“calling method which takes int”);
System.out.println(“i*j=” + (i*j));
}
2.Run time polymorphism/dynamic/late binding
Ø Method overridding
Method overriding is changing the method implementation of parent class method in the child class. Or changing the behaviour of the parent class in the child class.
While method overriding method signature should be same like followed by paranthesis and parameter.
While method overloading it should be widen.
Class Father{
Void drive(){
System.out.println(“drives cautiously…..”);
}
}
Class Son extends Father{
Void drive(){
System.out.println(“son drives uncautiously…..”);
}
}
Classs RunTimePolymorphismDemo{
Public static void main(String args[]){
Son son=new Son();
Son.drive();
}
}